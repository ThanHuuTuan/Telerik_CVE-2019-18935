import re
import requests
import argparse
import random
import time
import ipaddress
import traceback
requests.packages.urllib3.disable_warnings() # disable SSL warnings

help_example = "EXAMPLE: telerik_rce_check -t 104.28.18.139"
parser = argparse.ArgumentParser(description='Telerik RAU RCE Detection'+'\n\n'+ help_example, formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-url', '--url')
parser.add_argument('-t', '--target')
parser.add_argument('-r', '--range')
parser.add_argument('-iL', '--inputfile', help='Specify a filename for bulk target scanning.')
parser.add_argument('-search', action='store_true', help='Searches IPv4 space for vulnerable hosts. (2 Second delay)')
args = parser.parse_args()

vuln_table = {"title":"CVE-2019-18935 - Telerik UI Javascript Deserialization RCE",
		"state":"NOT_VULN",
		"risk_factor":"HIGH",
		"references":"https://nvd.nist.gov/vuln/detail/CVE-2019-18935",
		"CVE":"CVE-2019-18935",
		"CWE":"CWE-913",
		"CVSS2":"8.5",
		"Description":"""
		Telerik UI for ASP.NET AJAX through 2019.3.1023 contains a 
		.NET deserialization RCE vulnerability in the RadAsyncUpload function.

			-- 	As of 2020.1.114, a default setting prevents the exploit. 
			--  In 2019.3.1023, but not earlier versions, a non-default 
			--  setting can prevent exploitation.
			
			-- This is exploitable 
			-- when the encryption keys are known due to the presence of CVE-2017-11317 or 
			-- CVE-2017-11357.  Exploitation can result in remote code execution. 
		"""}

vuln_checks = ['/Telerik.Web.UI.WebResource.axd?type=rau',
				'/aspnet-ajax/Telerik.Web.UI.WebResource.axd?type=rau']		
		
def print_vuln_table():
	print(vuln_table['title'])
	print(vuln_table['state'])
	print(vuln_table['risk_factor'])
	print(vuln_table['references'])
	print(vuln_table['CVE'])
	print(vuln_table['CWE'])
	print(vuln_table['Description'])
	

def is_valid_ip(ip):
	"""Checks if IP is valid"""
	test = re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$",ip)
	if test:
		return True
	else:
		return False
		

def is_valid_hostname(hostname):
    """Checks if hostname is valid for scanning """
    if hostname[-1] == ".":
        # strip exactly one dot from the right, if present
        hostname = hostname[:-1]
    if len(hostname) > 253:
        return False
    labels = hostname.split(".")
    # the TLD must be not all-numeric
    if re.match(r"[0-9]+$", labels[-1]):
        return False
    allowed = re.compile(r"(?!-)[a-z0-9-]{1,63}(?<!-)$", re.IGNORECASE)
    return all(allowed.match(label) for label in labels)		

def random_IP():
	oct1 = random.randint(1,254)
	oct2 = random.randint(1,254)
	oct3 = random.randint(1,254)
	oct4 = random.randint(1,254)
	ip = str(oct1) + "." + str(oct2) + "." + str(oct3) + "." + str(oct4)
	return ip


def search():    
	while 1:
		check_vuln(random_IP())
		time.sleep(2)
		
		
def range_scan(netrange):
	print("Running range scan...")
	for i in [str(ip) for ip in ipaddress.IPv4Network(netrange)]:
		check_vuln_bulk(i)



def check_version_vuln(version):
	print(version)
	year = version.split(".")[0]
	sub = version.split(".")[1]
	if (int(year) <= 2020) and (int(sub) <= 2):
		return True
	else:
		return False

def read_from_file(filepath):
	with open(filepath) as fd:
		targets = fd.read().splitlines()
	return targets
	
def check_source_for_ver(target):
	print("Checking target for vulnerable versions...")
	s = '20[0-9]{2}(?:\.[0-9]*)+'
	source = requests.get("https://"+target, verify=False)
	result = re.search(s, source.text)
	results = re.findall(s, source.text)
	#print(len(results))
	print("Identified version matches:")
	status = False
	for i in results:
		if (len(i.split(".")) >= 3):
			if check_version_vuln(i):
				#print(i, " :: VULNERABLE")
				status = True
	return status
	
def check_vuln(target):
	status = ""
	string_text = "RadAsyncUpload handler is registered succesfully"
	print("Checking: " + target)
	for uri in vuln_checks:
		try:
			r = requests.get('https://'+ target + uri, verify=False)
			status = r.status_code
			if status == 200:
				# if r.body contains "RadAsyncUpload handler is registered succesfully"
				if string_text in r.text:
					print("[!] RAU Module Found [ " + target + uri + " ]!")
					if check_source_for_ver(target):
						print_vuln_table()
						return
				return
			else:
				print("Telerik RAU Module not found on " + target + ":Status " + str(status))
		except Exception as ex:
			traceback.print_exc()
			
def check_vuln_bulk(target):
	status = ""
	string_text = "RadAsyncUpload handler is registered succesfully"
	print("Checking: " + target)
	for uri in vuln_checks:
		try:
			r = requests.get('https://'+ target + uri, timeout=0.5, verify=False)
			status = r.status_code
			if status == 200:
				# if r.body contains "RadAsyncUpload handler is registered succesfully"
				if string_text in r.text:
					print("[!] RAU Module Found [ " + target + uri + " ]!")
					if (check_source_for_ver(target)):
						print_vuln_table()
						return
				return
			else:
				print("Telerik RAU Module not found on " + target + ".   Status (" + str(status) + ")")
		except Exception as ex:
			pass


if __name__=='__main__':
	if args.inputfile:
		targets = read_from_file(args.inputfile)
		for host in targets:
			check_vuln_bulk(host)

	elif args.search:
		search()

	elif args.target:
		if is_valid_ip(args.target):
			check_vuln(args.target)

		elif is_valid_hostname(args.target):
			check_vuln(args.target)

	elif args.range:
		range_scan(args.range)

	else:
		parser.print_help()
else:
	parser.print_help()	
		


