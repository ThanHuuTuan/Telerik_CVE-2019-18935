import re
import requests
import argparse
import random
import time
import ipaddress
import traceback
requests.packages.urllib3.disable_warnings() # disable SSL warnings

# Arguments are IP or Hostname
# Checks for the existence of Telerik RAU module ---> May be vulnerable
#  IF RAU exists
#      
help_example = "EXAMPLE: telerik_rce_check -t 104.28.18.139"
parser = argparse.ArgumentParser(description='Telerik RAU RCE Detection'+'\n\n'+ help_example, formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-url', '--url')
parser.add_argument('-t', '--target')
parser.add_argument('-r', '--range')
parser.add_argument('-iL', '--inputfile', help='Specify a filename for bulk target scanning.')
parser.add_argument('-search', action='store_true', help='Searches IPv4 space for vulnerable hosts. (2 Second delay)')
args = parser.parse_args()

# argument based testing here
# IP
# hostname
# URL
# TBD --> bulk of all three

vuln_table = {"title":"CVE-2019-18935 - Telerik UI Javascript Deserialization RCE",
		"state":"NOT_VULN",
		"risk_factor":"HIGH",
		"references":"https://nvd.nist.gov/vuln/detail/CVE-2019-18935",
		"CVE":"CVE-2019-18935",
		"CWE":"CWE-913",
		"CVSS2":"8.5",
		"Description":"""
		Telerik UI for ASP.NET AJAX through 2019.3.1023 contains a 
		.NET deserialization RCE vulnerability in the RadAsyncUpload function.

			-- 	As of 2020.1.114, a default setting prevents the exploit. 
			--  In 2019.3.1023, but not earlier versions, a non-default 
			--  setting can prevent exploitation.
			
			-- This is exploitable 
			-- when the encryption keys are known due to the presence of CVE-2017-11317 or 
			-- CVE-2017-11357.  Exploitation can result in remote code execution. 
		"""}

def is_valid_ip(ip):
	"""Checks if IP is valid"""
	test = re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$",ip)
	if test:
		return True
	else:
		return False
		

def is_valid_hostname(hostname):
    """Checks if hostname is valid for scanning """
    if hostname[-1] == ".":
        # strip exactly one dot from the right, if present
        hostname = hostname[:-1]
    if len(hostname) > 253:
        return False
    labels = hostname.split(".")
    # the TLD must be not all-numeric
    if re.match(r"[0-9]+$", labels[-1]):
        return False
    allowed = re.compile(r"(?!-)[a-z0-9-]{1,63}(?<!-)$", re.IGNORECASE)
    return all(allowed.match(label) for label in labels)		

def random_IP():
	oct1 = random.randint(1,254)
	oct2 = random.randint(1,254)
	oct3 = random.randint(1,254)
	oct4 = random.randint(1,254)
	ip = str(oct1) + "." + str(oct2) + "." + str(oct3) + "." + str(oct4)
	return ip


def search():    
	while 1:
		check_vuln(random_IP())
		time.sleep(2)
		
		
def range_scan(netrange):
	print("Running range scan...")
	for i in [str(ip) for ip in ipaddress.IPv4Network(netrange)]:
		check_vuln(i)



def check_version_vuln(version):
	print(version)
	year = version.split(".")[0]
	sub = version.split(".")[1]
	if (int(year) <= 2020) and (int(sub) <= 2):
		return True
	else:
		return False
	# parse the version number
	# check first octet
	# check second octet
	# return result

def read_from_file(filepath):
	with open(filepath) as fd:
		targets = fd.read().splitlines()
	return targets
	
def check_source_for_ver(target):
	print("Checking target for vulnerable versions...")
	s = '20[0-9]{2}(\.[0-9]*)+'
	source = requests.get("https://"+target, timeout=0.500, verify=False)
	result = re.search(s, source.text)
	#print(result.group(0))
	if result:
		match = result.group()
		print(match)
		if check_version_vuln(match):
			print("Status: VULNERABLE")
		else:
			print("Status: NOT VULNERABLE")
	else:
		print("Could not find version information.")

	
vuln_checks = ['/Telerik.Web.UI.WebResource.axd?type=rau',
				'/aspnet-ajax/Telerik.Web.UI.WebResource.axd?type=rau']

def check_vuln(target):
	status = ""
	string_text = "RadAsyncUpload handler is registered succesfully"
	print("Checking: " + target)
	for uri in vuln_checks:
		try:
			r = requests.get('https://'+ target + uri, timeout=0.250, verify=False)
			status = r.status_code
			if status == 200:
				# if r.body contains "RadAsyncUpload handler is registered succesfully"
				if string_text in r.text:
					print("[!] RAU Module Found [ " + target + uri + " ]!")
					check_source_for_ver(target)
					return
				return
			else:
				print("Telerik RAU Module not found on " + target + ":Status " + status)
		except Exception as ex:
			pass
			#traceback.print_exc()
			
	
#r = requests.get('https://' +hostname+ '/Telerik.Web.UI.WebResource.axd?type=rau', verify=False)
#r = requests.get(url, verify=False)

if __name__=='__main__':
	if args.inputfile:
		targets = read_from_file(args.inputfile)
		for host in targets:
			check_vuln(host)
	elif args.search:
		search()
	elif args.target:
		if is_valid_ip(args.target):
			check_vuln(args.target)
		elif is_valid_hostname(args.target):
			check_vuln(args.target)
	elif args.range:
		range_scan(args.range)
	else:
		parser.print_help()
else:
	parser.print_help()	
		


